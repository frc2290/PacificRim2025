package frc.utils;

import com.revrobotics.sim.SparkAbsoluteEncoderSim;
import com.revrobotics.sim.SparkFlexSim;
import com.revrobotics.sim.SparkMaxSim;
import com.revrobotics.sim.SparkRelativeEncoderSim;
import com.revrobotics.spark.SparkClosedLoopController;
import com.revrobotics.spark.SparkBase.ControlType;
import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.math.system.plant.LinearSystemId;
import edu.wpi.first.wpilibj.simulation.DCMotorSim;

/**
 * Simulation model for a single swerve module.  This class is responsible for
 * integrating the steer motor state and computing the longitudinal wheel force
 * generated by the drive motor based on the current rolling speed and applied
 * voltage.
 *
 * <p>The intent of this class is to be lightweight and independent of any
 * particular robot implementation.  Sensor mirroring is performed by writing to
 * the provided Spark simulation encoder objects when available, but these are
 * optional and may be {@code null} for users that only care about the physics
 * results.</p>
 *
 * <p>The steering motor is expected to be modeled with a NEO 550 and its
 * corresponding gear reduction (e.g. 46.45:1 on a REV MAXSwerve module) so that
 * the internal closed-loop controller matches real hardware behavior.</p>
 */
public class SwerveModuleSim {
  private final DCMotor m_driveMotor;
  private final double m_driveGearRatio;
  private final double m_wheelRadius;
  private final double m_driveEfficiency;

  private final DCMotor m_steerMotor;
  private final double m_steerGearRatio;

  private final SparkFlexSim m_driveSim;
  private final SparkMaxSim m_steerSim;
  private final SparkClosedLoopController m_driveController;
  private final SparkClosedLoopController m_steerController;
  private final SparkRelativeEncoderSim m_driveEncoderSim;
  private final SparkAbsoluteEncoderSim m_steerEncoderSim;
  private final DCMotorSim m_steerModel;

  // Open-loop output used when no Spark simulation is provided.
  private double m_openLoopOutput = 0.0;

  // Steering state.  The azimuth is driven by the SparkMaxSim's internal motor
  // model and closed-loop controller.
  private double m_azimuth;
  private double m_steerVelocity;

  // Offset to apply when mirroring the absolute encoder (rad). This lets the
  // simulated absolute encoder match the robot's expected zeroing convention
  // where absolute = relative + chassisAngularOffset.
  private double m_encoderOffset = 0.0;

  /** Sets the absolute encoder offset (radians). */
  public void setEncoderOffset(double offset) {
    m_encoderOffset = offset;
    // Immediately mirror with the new offset so initial state is consistent
    if (m_steerEncoderSim != null) {
      m_steerEncoderSim.setPosition(m_azimuth + m_encoderOffset);
      m_steerEncoderSim.setVelocity(m_steerVelocity);
    }
  }

  /**
   * Record containing the longitudinal force vector produced by the wheel and the
   * corresponding rolling speed used to generate it.
   */
  public static class ModuleForce {
    public final double fx;
    public final double fy;
    public final double vRoll;

    public ModuleForce(double fx, double fy, double vRoll) {
      this.fx = fx;
      this.fy = fy;
      this.vRoll = vRoll;
    }
  }

  /**
   * Creates a new {@link SwerveModuleSim}.
   *
   * @param driveMotor      DC motor model for the drive motor
   * @param driveGearRatio  drive gearbox ratio (motor revolutions / wheel revolutions)
   * @param wheelRadius     wheel radius in meters
   * @param driveEfficiency net efficiency of the drive transmission
   * @param steerMotor      DC motor model for the steer motor
   * @param steerGearRatio  steering gearbox ratio (motor revolutions / module revolutions)
   * @param driveSim        optional SparkFlexSim for the drive motor (may be null)
   * @param driveController optional closed-loop controller for the drive motor
   * @param steerSim        optional SparkMaxSim for the steering motor. When
   *                        provided, the sim's internal closed-loop algorithms are
   *                        used to update the module azimuth so steer volts need
   *                        not be supplied externally.
   * @param steerController optional closed-loop controller for the steering motor
   */
  public SwerveModuleSim(
      DCMotor driveMotor,
      double driveGearRatio,
      double wheelRadius,
      double driveEfficiency,
      DCMotor steerMotor,
      double steerGearRatio,
      SparkFlexSim driveSim,
      SparkClosedLoopController driveController,
      SparkMaxSim steerSim,
      SparkClosedLoopController steerController) {
    m_driveMotor = driveMotor;
    m_driveGearRatio = driveGearRatio;
    m_wheelRadius = wheelRadius;
    m_driveEfficiency = driveEfficiency;
    m_steerMotor = steerMotor;
    m_steerGearRatio = steerGearRatio;

    SparkMaxSim steerSimFinal = steerSim;
    SparkClosedLoopController steerControllerFinal = steerController;
    if (steerSimFinal == null && steerMotor != null) {
      SparkMax spark = new SparkMax(0, MotorType.kBrushless);
      steerSimFinal = new SparkMaxSim(spark, steerMotor);
      steerControllerFinal = spark.getClosedLoopController();
    }

    m_driveSim = driveSim;
    m_steerSim = steerSimFinal;
    m_driveController = driveController;
    m_steerController = steerControllerFinal;
    m_driveEncoderSim = driveSim != null ? driveSim.getRelativeEncoderSim() : null;
    m_steerEncoderSim = steerSimFinal != null ? steerSimFinal.getAbsoluteEncoderSim() : null;
    m_steerModel =
        steerMotor != null
            ? new DCMotorSim(
                LinearSystemId.createDCMotorSystem(steerMotor, 0.01, m_steerGearRatio),
                steerMotor)
            : null;

    m_azimuth = 0.0;
    m_steerVelocity = 0.0;
  }

  /** Updates the steering state and mirrors it to attached Spark simulators. */
  private void updateSteer(double steerSetpoint, double busVoltage, double dt) {
    if (m_steerSim != null && m_steerModel != null) {
      if (m_steerController != null) {
        m_steerController.setReference(steerSetpoint, ControlType.kPosition);
      }

      double appliedVolts = m_steerSim.getAppliedOutput() * busVoltage;
      m_steerModel.setInputVoltage(appliedVolts);
      m_steerModel.update(dt);

      m_azimuth = m_steerModel.getAngularPositionRad();
      m_steerVelocity = m_steerModel.getAngularVelocityRadPerSec();

      double rotorRPM = m_steerModel.getAngularVelocityRPM() * m_steerGearRatio;
      m_steerSim.iterate(rotorRPM, busVoltage, dt);
      if (m_steerEncoderSim != null) {
        m_steerEncoderSim.setPosition(m_azimuth + m_encoderOffset);
        m_steerEncoderSim.setVelocity(m_steerVelocity);
      }
    } else {
      // If no steering simulator is provided, assume ideal control
      m_azimuth = steerSetpoint;
      m_steerVelocity = 0.0;
    }
  }

  /**
   * Performs a simulation step for this module.  The steering angle is updated
   * and the drive force is calculated based on the robot's previous body-frame
   * velocity.
   *
   * @param driveVelocity desired wheel linear velocity setpoint (m/s)
   * @param steerAngle    desired module azimuth setpoint (rad)
   * @param busVoltage    current battery voltage for running the controllers
   * @param robotVx       robot velocity x in the body frame (m/s)
   * @param robotVy       robot velocity y in the body frame (m/s)
   * @param robotOmega    robot angular velocity (rad/s)
   * @param modulePos     module position relative to robot center in robot frame
   * @param dt            timestep in seconds
   * @return              longitudinal force vector generated by the wheel
   */
  public ModuleForce update(
      double driveVelocity,
      double steerAngle,
      double busVoltage,
      double robotVx,
      double robotVy,
      double robotOmega,
      Translation2d modulePos,
      double dt) {
    // Step 1: integrate steering state using closed-loop controller
    updateSteer(steerAngle, busVoltage, dt);

    // Drive controller produces an applied output based on desired speed
    double driveVolts;
    if (m_driveSim != null) {
      if (m_driveController != null) {
        m_driveController.setReference(driveVelocity, ControlType.kVelocity);
      }
      driveVolts = m_driveSim.getAppliedOutput() * busVoltage;
    } else {
      driveVolts = m_openLoopOutput * busVoltage;
    }

    // Step 2: compute contact velocity and resulting drive force
    double vcx = robotVx - robotOmega * modulePos.getY();
    double vcy = robotVy + robotOmega * modulePos.getX();

    double tX = Math.cos(m_azimuth);
    double tY = Math.sin(m_azimuth);
    double vRoll = vcx * tX + vcy * tY;

    // Drive motor back-EMF model
    double motorSpeed = m_driveGearRatio * vRoll / m_wheelRadius; // rad/s
    double backEMF = motorSpeed / m_driveMotor.KvRadPerSecPerVolt;
    double current = (driveVolts - backEMF) / m_driveMotor.rOhms;
    double torque = m_driveMotor.KtNMPerAmp * current;
    double force = m_driveEfficiency * m_driveGearRatio * torque / m_wheelRadius;

    double fx = force * tX;
    double fy = force * tY;

    return new ModuleForce(fx, fy, vRoll);
  }

  /**
   * Sets the applied output of the simulated drive motor. This allows open-loop
   * voltage control during tests without requiring a {@link SparkClosedLoopController}.
   *
   * @param output Fractional output (-1 to 1) applied to the drive motor
   */
  public void setDriveOutput(double output) {
    if (m_driveSim != null) {
      m_driveSim.setAppliedOutput(output);
    } else {
      m_openLoopOutput = output;
    }
  }

  /**
   * Mirrors the final wheel kinematics to the simulated drive encoders.
   */
  public void updateDriveSensor(double vRoll, double dt, double busVoltage) {
    // Convert wheel linear speed to motor units
    double distPerRot = 2 * Math.PI * m_wheelRadius / m_driveGearRatio; // meters per motor rotation
    double motorRPM = (vRoll / distPerRot) * 60.0;
    if (m_driveEncoderSim != null) {
      double newPos = m_driveEncoderSim.getPosition() + (vRoll * dt) / distPerRot; // motor rotations
      m_driveEncoderSim.setPosition(newPos);
      m_driveEncoderSim.setVelocity(motorRPM); // motor RPM
    }
    if (m_driveSim != null) {
      m_driveSim.iterate(motorRPM, busVoltage, dt);
    }
  }

  /** Returns the current wheel azimuth in radians. */
  public double getAzimuth() {
    return m_azimuth;
  }
}

